# CotizadorArkaJP

Análisis personal del microservicio Arca Cotizador

Al analizar el microservicio Arca Cotizador, pude comprender que se trata de un sistema diseñado para gestionar la generación de cotizaciones de productos de forma reactiva y no bloqueante. Aprovecha la programación asíncrona a través de objetos como Mono y Flux, lo que permite que las operaciones se ejecuten de manera eficiente sin detener la aplicación.
La estructura del proyecto está muy bien organizada y responde claramente a una arquitectura limpia, donde cada capa cumple un rol específico dentro del flujo del microservicio. En el paquete domain.model se encuentran las clases que representan el corazón del negocio: las solicitudes, los ítems y las respuestas de cotización. Aquí se definen entidades como CotizacionRequest, CotizacionResponse, ItemCotizacion y ItemCotizado, que permiten estructurar los datos de manera coherente entre las distintas capas del sistema.
Por ejemplo, CotizacionRequest representa la información que envía el cliente cuando solicita una cotización: incluye el identificador del cliente, la lista de productos y las cantidades deseadas. A partir de esa solicitud, el sistema genera una respuesta (CotizacionResponse) que contiene el identificador único de la cotización, los ítems ya valorados, el total calculado, las fechas de emisión y vencimiento, y el estado de la cotización. Este modelo me pareció muy claro y bien diseñado, porque separa con precisión lo que se recibe del usuario y lo que se devuelve como resultado final.
En la capa de aplicación, específicamente en el paquete application.service, se encuentra la lógica de negocio. La interfaz CotizacionService define los métodos principales del microservicio, como generar y obtener cotizaciones, ambos manejados de forma reactiva. Su implementación, CotizacionServiceImpl, me pareció muy interesante porque muestra paso a paso cómo se construye una cotización.
Primero, se genera un identificador único utilizando UUID.randomUUID(). Luego, se recorre la lista de productos solicitados, se asignan precios simulados (en este caso, de forma estática) y se calculan los subtotales de cada ítem. Finalmente, se suman los valores individuales para obtener el total general.
uso de Mono<CotizacionResponse> como tipo de retorno, porque demuestra que el servicio está preparado para integrarse en un entorno totalmente reactivo, donde las respuestas pueden procesarse sin bloquear el hilo principal. Esto hace que el microservicio sea más escalable y eficiente, sobre todo en sistemas donde se manejan múltiples peticiones simultáneamente.
En cuanto a la capa de infraestructura, dentro del paquete infrastructure.adapter.in.web, se encuentra el CotizacionController, que expone los endpoints REST del microservicio. A través de rutas como /api/cotizaciones, el sistema permite crear nuevas cotizaciones mediante peticiones POST, consultar cotizaciones existentes con GET y verificar el estado general del servicio. Me pareció que la estructura de los endpoints está bien definida y mantiene una convención clara, lo que facilita su comprensión y uso por parte de otros servicios o clientes.
Además, el proyecto cuenta con un controlador adicional llamado CotizadorReactiveController. Este no se centra tanto en la lógica de negocio, sino en ofrecer endpoints que ayudan a monitorear, probar y diagnosticar el comportamiento del microservicio. Incluye rutas como /health, que confirma que el servicio está activo; /info, que muestra información del sistema; /stream, que genera flujos de datos reactivos; y /reactive-test, útil para realizar pruebas de comportamiento. Me pareció una excelente herramienta de apoyo para verificar el funcionamiento del sistema en tiempo real.
La clase principal, ArcaCotizadorApplication, es la encargada de iniciar todo el contexto de Spring Boot. Está anotada con @SpringBootApplication y @EnableDiscoveryClient, lo que significa que este microservicio puede registrarse automáticamente en un servidor de descubrimiento, como Eureka o Consul. Esto confirma que el Arca Cotizador está pensado para formar parte de una arquitectura distribuida de microservicios, donde varios componentes trabajan en conjunto.
También observé que el proyecto incluye archivos de configuración como application.yml, bootstrap.yml y application.properties. Estos archivos controlan aspectos como el puerto, el nombre del servicio, y las conexiones con otros sistemas o servidores de configuración centralizados. En proyectos grandes, estos archivos son esenciales para mantener la organización y la conexión entre los diferentes servicios del ecosistema.

algo que me gustaría mencionar a reactividad y la arquitectura hexagonal, los cuales aportan eficiencia, claridad estructural y una alta capacidad de respuesta dentro del sistema. Por el lado de la reactividad, esta se implementa mediante el uso de Spring WebFlux, un módulo que permite construir aplicaciones asíncronas y no bloqueantes. Esto significa que el microservicio puede atender múltiples solicitudes simultáneamente sin que unas dependan del resultado de otras, aprovechando mejor los recursos del sistema. En este caso, observé que tanto los controladores como los servicios utilizan los tipos reactivos Mono y Flux, propios de la librería Project Reactor. La diferencia entre ambos radica en la cantidad de elementos que pueden emitir:
Mono representa una secuencia que devuelve un solo valor o ninguno, ideal para operaciones puntuales como obtener o generar una cotización específica.
Flux, en cambio, representa una secuencia que puede emitir múltiples valores a lo largo del tiempo, siendo útil cuando se necesita transmitir flujos continuos de datos, como en el endpoint /stream del controlador reactivo, que emite eventos periódicos de manera constante.
Por otro lado, la arquitectura hexagonal se refleja en la organización interna del microservicio. La capa de dominio contiene las entidades principales (como las cotizaciones y los ítems), que son el corazón del negocio; la capa de aplicación gestiona la lógica central (por ejemplo, el cálculo del total de una cotización); y la capa de infraestructura actúa como adaptadora, encargándose de exponer la API y manejar las peticiones externas. Esta estructura separada no solo favorece la mantenibilidad y la escalabilidad, sino que también permite aislar el dominio del resto del sistema, haciendo posible reemplazar tecnologías o adaptadores sin afectar la lógica principal. En conclusión, la combinación de reactividad y arquitectura hexagonal en el microservicio Arca Cotizador demuestra una apuesta por el diseño moderno y eficiente. Gracias a esta integración, el servicio logra ser más flexible, escalable y capaz de responder con fluidez en entornos de alta demanda, manteniendo siempre una estructura clara y coherente.
